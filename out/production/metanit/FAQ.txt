/////Коммантарии и общая структура/////

/*
    многострочный комментарий
    Объявление нового класса,
    который содержит код программы
*/

public class Program{   // начало объявления класса Program

    // определение метода main
    public static void main (String args[]){    // объявление нового метода

         System.out.println("Hello Java!");     // вывод строки на консоль
    }   // конец объявления нового метода
} // конец объявления класса Program

-------------------------------------------------------------------------
/////Переменные://///

Структура объявления переменных:
    тип_данных имя_переменной   // объявление переменной
Ограничения для имени переменной:
    * Имя переменной не может начинаться с цифры
    * Нет знаков пунктуации и пробелов
    * Не может быть ключевым словом языка Java
    * Регистрозависимость: int num != int NUM
Пример:
    Объявление одной переменной
        int x = 10; // объявили тип и имя переменной
        System.out.println(x); // вывели значение переменно = 10
    Объявление нескольких переменных
        int x = 10, y = 15;
        System.out.print(x);
        System.out.print(y);
В процессе выполнения кода, можно изменять переменные.
Пример:
    int x = 10; // объявили переменную
    System.out.println(x); // вывели первое присвоенное значение переменной = 10
    x = 25; // изменили ранее присвоенное значение переменной
    System.out.println(x); // вывели уже новое значение переменной = 25
При объявлении переменной через var, тип для нее выводится автоматически,
в зависимости от значения, которое ей присваивается
Пример:
    var x = 10; // значит, var = int
-------------------------------------------------------------------------
/////Константы://///

Отличия констант от переменных:
    * Значение присваивается один раз и навсегда
    * В начале идет ключевое слово final
    * Имя константы, как правило, в верхнем регистре
Пример:
    final int LIMIT = 5;
    System.out.print(LIMIT); // вывели значение константы = 5
-------------------------------------------------------------------------
/////Типы данных://///

    * boolean: хранит значение true или false
    * byte: хранит целое число от -128 до 127
    * short: хранит целое число от -32768 до 32767
    * int: хранит целое число от -2147483648 до 2147483647
    * long: хранит целое число от –9 223 372 036 854 775 808 до 9 223 372 036 854 775 807
    * double: хранит число с плавающей точкой (больше, чем float)
    * float: хранит число с плавающей точкой (меньше, чем double)
    * char: хранит одиночный символ в кодировке UTF-16. Диапазон хранимых значений от 0 до 65535

/////Целые числа://///

    Все целочисленные значения воспринимаются как int.
    Чтобы система поняла, что переменной присвоено значение типа, отличного от int,
    необходимо к числу дописать суффикс l
        Пример:
            * long num = 2147483649L;

/////Числа с плавающей запятой/////

    Все значения с плавающей запятой, система воспринимает как double.
    Чтобы система поняла, что тип переменной float, необходимо к числу дописать суффикс f
        Пример:
            * float fl = 30.6f;

/////Символы и строки/////

    'a' - символьный тип (char)
    "а" - строковый тип (string)
        'a' != "a"
-------------------------------------------------------------------------
/////Консольный ввод/вывод в Java://///

Для взаимодействия с консолью в Java применяется класс System

/////Вывод в консоль/////

Для вывода в классе System определен объект out, в котором определен метод println
    println - Выводит информацию с переносом строки
    print - Выводит информацию в одну строку
    printf - Выводит ворматированную строку, подставляя в неё значение спецификатора (Например:%d)
        Пример:
            System.out.print("Hello world!");

Подстановка в выводимую строку данных:
    Пример:
        public class Program {
            public static void main(String[] args) {
                int x = 5;
                int y = 6;
                // Ниже использован специйикатор %d, который примет первое, затем второе значение
                System.out.printf("x=%d; y=%d \n", x, y);
            }
        }

Виды спецификаторов:
    %d - для вывода целочисленных значений
    %f - для вывода чисел с плавающей запятой
    %с - для вывода одиночного символа
    %s - для вывода строкового значения
        Пример:
        // Выведет Name: Tom  Age: 30  Height: 1,70
            System.out.printf("Name: %s  Age: %d  Height: %.2f \n", name, age, height);

/////Ввод с консоли/////

* Для ввода чаще используют класс Scanner, который использует System.in
* Для использования класса Scanner необходимо импортировать его из пакета java.util.Scanner
* Для получения введенного значения, необходимо указать соответствующий метод:
    * next(): считывает введенную строку до первого пробела
    * nextLine(): считывает всю введенную строку
    * nextInt(): считывает введенное число int
    * nextDouble(): считывает введенное число double
    * nextBoolean(): считывает значение boolean
    * nextByte(): считывает введенное число byte
    * nextFloat(): считывает введенное число float
    * nextShort(): считывает введенное число short
        Пример в файле: Q2.InputInConsole

-------------------------------------------------------------------------
/////Арифметические операции/////

++ (префиксный инкремент)
    Сначала переменная "а" увеличивается на 1, потом приравнивают к ней "b"
        Пример:
            int a = 8;
            int b = ++a;
            System.out.println(a);  // 9
            System.out.println(b);  // 9

++ (постфиксный инкремент)
    Сначала переменная "а" приравнивается к "b", потом увеличивается "а" на 1
        Пример:
            int a = 8;
            int b = a++;
            System.out.println(a);  // 9
            System.out.println(b);  // 8

-- (префиксный декремент)
    Сначала переменная "a" уменьшается на 1, потом приравнивают к ней "b"
        Пример:
            int a = 8;
            int b = --a;
            System.out.println(a);  // 7
            System.out.println(b);  // 7

-- (постфиксный декремент)
    Сначала переменная "а" приравнивается к "b", потом уменьшается "а" на 1
        Пример:
            int a = 8;
            int b = a--;
            System.out.println(a);  // 7
            System.out.println(b);  // 8

Приоритет математических операций (От высшего к нисшему)
    1.  ++ (постфиксный инкремент), -- (постфиксный декремент)
    2.  ++ (префиксный инкремент), -- (префиксный декремент)
    3.  * (умножение), / (деление), % (остаток от деления)
    4.  + (сложение), - (вычитание)
        Пример:
            int a = 8;
            int b = 7;
            int c = a + 5 * ++b;
            System.out.println(c);  // 48

-------------------------------------------------------------------------
/////Логические операции/////

    * |
        c=a|b; (c равно true, если либо a, либо b (либо и a, и b) равны true, иначе c будет равно false)
    * &
        c=a&b; (c равно true, если и a, и b равны true, иначе c будет равно false)
    * !
        c=!b; (c равно true, если b равно false, иначе c будет равно false)
    * ^
        c=a^b; (c равно true, если либо a, либо b (но не одновременно) равны true, иначе c будет равно false)
    * || (Сначала вычисляет первое значение, потом второе. Может остановить вычисление на первом)
        c=a||b; (c равно true, если либо a, либо b (либо и a, и b) равны true, иначе c будет равно false)
    * && (Сначала вычисляет первое значение, потом второе. Может остановить вычисление на первом)
    c=a&&b; (c равно true, если и a, и b равны true, иначе c будет равно false)

-------------------------------------------------------------------------
/////Операции присваивания/////

    =
        просто приравнивает одно значение другому: c=b;
    +=
        c+=b; (переменной c присваивается результат сложения c и b)
    -=
        c-=b; (переменной c присваивается результат вычитания b из c)
    *=
        c*=b; (переменной c присваивается результат произведения c и b)
    /=
        c/=b; (переменной c присваивается результат деления c на b)
    %=
        c%=b; (переменной c присваивается остаток от деления c на b)
    &=
        c&=b; (переменной c присваивается значение c&b)
    |=
        c|=b; (переменной c присваивается значение c|b)
    ^=
        c^=b; (переменной c присваивается значение c^b)
    <<=
        c<<=b; (переменной c присваивается значение c<<b)
    >>=
        c>>=b; (переменной c присваивается значение c>>b)
    >>>=
        c>>>=b; (переменной c присваивается значение c>>>b)
            Пример:
                int a = 5;
                a += 10;        // 15
                a -= 3;         // 12
                a *= 2;         // 24
                a /= 6;         // 4
                a <<= 4;      // 64
                a >>= 2;      // 16
                System.out.println(a);  // 16

-------------------------------------------------------------------------
/////Преобразования базовых типов данных/////

Усечение рациональных чисел до целых
    Без применения математической библиотеки Java:
        double a = 56.9898;
        int b = (int)a; // Выведет 56
    С применением математической библиотеки Java:
        double a = 56.9898;
        int b = (int)Math.round(a); // Выведет 57

Преобразование при операциях
    Правила:
        1. если один из операндов операции относится к типу double,
        то и второй операнд преобразуется к типу double
        2. если предыдущее условие не соблюдено, а один из операндов операции относится к типу float,
        то и второй операнд преобразуется к типу float
        3. если предыдущие условия не соблюдены, один из операндов операции относится к типу long,
        то и второй операнд преобразуется к типу long
        4. иначе все операнды операции преобразуются к типу int
            Пример:
                int a = 3;
                double b = 4.6;
                double c = a+b; // Выведет 7.6

-------------------------------------------------------------------------
/////Условные конструкции/////

/////Конструкция if/else/////
    Пример 1:
        int num1 = 6;
        int num2 = 8;
        if(num1>num2){
            System.out.println("Первое число больше второго");
        }
        else if(num1<num2){
            System.out.println("Первое число меньше второго");
        }
        else{
            System.out.println("Числа равны");
        }

    Пример 2:
        int num1 = 8;
        int num2 = 6;
        if(num1 > num2 && num1>7){
            System.out.println("Первое число больше второго и больше 7");
        }

/////Конструкция switch/////
    Пример:
        int num = 8; // Ввели переменную
        switch(num){ // Запустили конструкцию

            case 1: // Сравниваем переменную с 1
                System.out.println("число равно 1"); // Если условие выполнено - выводим сообщение
                break; // Прекращаем процесс проверки выполнения условий
            case 8:
                System.out.println("число равно 8");
                num++;
                break;
            case 9:
                System.out.println("число равно 9");
                break;
            default: // Если ни одно из условий не выполнено - прекращаем процесс, выводим сообщение
                System.out.println("число не равно 1, 8, 9");
        }

/////Тернарная операция/////
    [первый операнд - условие] ? [второй операнд] : [третий операнд]
    В зависимости от условия тернарная операция возвращает второй или третий операнд: если условие
    равно true, то возвращается второй операнд; если условие равно false, то третий.
        Пример:
            int x=3;
            int y=2;
            int z = x<y? (x+y) : (x-y); // Если x<y, то z=(x+y). Иначе z=(x-y)
            System.out.println(z);

-------------------------------------------------------------------------
/////Циклы/////

/////Цикл for/////
Задаются условия, выполняется действие, потом проверяет условие
    Структура:
        for ([инициализация счетчика]; [условие]; [изменение счетчика])
        {
            // действия
        }
    Пример:
        for (int i = 1; i < 9; i++){
            System.out.printf("Квадрат числа %d равен %d \n", i, i * i);
        }

/////Цикл do/////
Сначала выполняет действие, потом проверяет условие
    Пример:
        int j = 7; // Объявили переменную
        do{ // Запустили цикл
            System.out.println(j); // Вывели в консоль
            j--; // Уменьшили значение переменной на 1
        }
        while (j > 0); //Проверили условие с учетом измененного в цикле значения переменной

/////Цикл while/////
Сначала проверяет условие, потом выполняет действие
    Пример:
        int j = 6;
        while (j > 0){

            System.out.println(j);
            j--;
        }

/////Оператор break/////
Позволяет выйти из цикла при выполнении условия, даже если цикл не закончен
    Пример:
       for (int i = 0; i < 10; i++){
           if (i == 5) // Когда счетчик i достиг равенства 5, то останавливается цикл
               break;
           System.out.println(i);
       }

/////Оператор continue/////
Пропускает итерацию, при выполнении условия внутри цикла и, продолжить цикл
    Пример:
        for (int i = 0; i < 10; i++){
            if (i == 5) // Нашли i равное 5
                continue; // Продолжаем цикл с i равное 6
            System.out.println(i); // i = 5 не выведется в консоль
        }

-------------------------------------------------------------------------
/////Массивы/////

/////Объявление и инициализация (кол-во элементов) массива. Одномерный/////
    Вариант 1:
        тип_данных название_массива[]; //Объявили массив
    Вариант 2:
        тип_данных[] название_массива; //Объявили массив
            Пример: int nums[] = new int[4];    // массив из 4 чисел
                    int[] nums2 = new int[5];   // массив из 5 чисел
                        Где new int[4] - инициализация

    Объявление, инициализация + задание конкретных значений в массиве (в фигурных скобках):
        Пример:
            // эти два способа равноценны
            int[] nums = new int[] { 1, 2, 3, 5 };
            int[] nums2 = { 1, 2, 3, 5 };

/////Длина массива/////
    Пример:
        int[] nums = {1, 2, 3, 4, 5};
        int length = nums.length;   // 5
    Вычислить последний элемент массива:
        Пример:
            int last = nums[nums.length-1];

/////Объявление и инициализация (кол-во элементов) массива. Многомерный/////
    Двухмерный:
        Пример:
            int[][] nums2 = { { 0, 1, 2 }, { 3, 4, 5 } };
            Где { 0, 1, 2 } - элементы первой строки, { 3, 4, 5 } - элементы второй строки
        int[2][3];. Количество квадратных скобок указывает на размерность массива.
        А числа в скобках - на количество строк и столбцов, соответственно
        Пример:
            // установим элемент первого столбца второй строки
            nums2[1][0]=44;
            System.out.println(nums2[1][0]);

    Трехмерный:
        Пример:
            int[][][] nums3 = new int[2][3][4]; ///2 элемента по оси Z, 3 по X, 4 gj Y

/////for (foreach) цикл для переборки массива/////

/////Перебор одномерного массива/////
/////Когда требуется ТОЛЬКО получить данные/////
    Пример:
        int[] array = new int[] { 1, 2, 3, 4, 5 }; // Создали массив
        for (int i : array){ // Запустили цикл
            System.out.println(i); // Выполнили действие с каждым найденным элементом (Вывели в консоль)
        }
/////Когда требуется ПОЛУЧИТЬ и ИЗМЕНИТЬ данные/////
    Пример:
        int[] array = new int[] { 1, 2, 3, 4, 5 }; // Создали массив
        for (int i=0; i<array.length;i++){ // Запустили цикл, задали условие от длины массива
            array[i] = array[i] * 2; // Умножили каждый элемент на 2
            System.out.println(array[i]); // Вывели в консоль каждый измененный элемент
        }

/////Перебор многомерного массива/////
    Пример:
        int[][] nums = new int[][] // Создали массив
        {
            {1, 2, 3}, // Присвоили значения элементам 1 ой строки
            {4, 5, 6}, // Присвоили значения элементам 2 ой строки
            {7, 8, 9} // Присвоили значения элементам 3 ей строки
        };
        for (int i = 0; i < nums.length; i++){ // Запустили цикл переборки строк
            for(int j=0; j < nums[i].length; j++){ // Запустили цикл переборки столбцов
                System.out.printf("%d ", nums[i][j]); // Вывели элементы 1я строка, 1ый столбец. 1я строка, 2ой столбец
            }
            System.out.println();
        }

-------------------------------------------------------------------------
/////Методы/////
    Методы вызываются в основном методе main
        Пример в файле run_method_in_main

-------------------------------------------------------------------------
/////Параметры методов/////
С помощью параметров мы можем передать в методы различные данные,
которые будут использоваться для вычислений
    Пример в файле param_for_method

-------------------------------------------------------------------------
/////Оператор return. Результат метода/////
Возвращает нам резудьтат выполнения метода
Пример в файле operator_return

-------------------------------------------------------------------------
/////Перегрузка методов/////
В программе мы можем использовать методы с одним и тем же именем, но с разными типами
и/или количеством параметров. Такой механизм называется перегрузкой методов (method overloading).

Здесь определено три варианта или три перегрузки метода sum(), но при его вызове в зависимости от типа
и количества передаваемых параметров система выберет именно ту версию, которая наиболее подходит.
    Пример:
        public class Program{

            public static void main(String[] args) {

                System.out.println(sum(2, 3));          // 5
                System.out.println(sum(4.5, 3.2));      // 7.7
                System.out.println(sum(4, 3, 7));       // 14
            }
            static int sum(int x, int y){

                return x + y;
            }
            static double sum(double x, double y){

                return x + y;
            }
            static int sum(int x, int y, int z){

                return x + y + z;
            }
        }

-------------------------------------------------------------------------
/////Введение в обработку исключений/////
/////Кострукция try...catch...finally/////
Применяется для обработки исключений. т.е., при возникновении ошибки,
разработчик может заранее позаботиться о возможности её возникновения. И,
чтобы из-за её появления не прервыалось выполнение программы - её обрабатывают.
В итоге, мы имеем сообщение, что ошибка была, но цикл программы пройден до логического финала.

* try – определяет блок кода, в котором может произойти исключение;
* catch – определяет блок кода, в котором происходит обработка исключения;
* finally – определяет блок кода, который является необязательным, но при его наличии выполняется в
любом случае независимо от результатов выполнения блока try.

    Пример:
        try{ //Как только в данном блоке происходит ошибка (Исключение), программа перейдет в блок catch
            int[] numbers = new int[3];
            numbers[4]=45; // Тут произойдет ошибка
            System.out.println(numbers[4]);
        }
        catch(Exception ex){ // (тип_исключения имя_переменной) Типы исключений можно погуглить под наши потребности

            ex.printStackTrace();
        }
        System.out.println("Программа завершена");

Исключений может быть несколько.
Подробнее в файле TryCatchFinaly

Если нам необходимо самостоятельно придумать исключение (Валидация, например).
То применяется оператор throw (т.е., которое не стандартное)
    Пример:
        import java.util.Scanner;
        public class FirstApp {

            public static void main(String[] args) {

                try{
                    Scanner in = new Scanner(System.in);
                    int x = in.nextInt();
                    if(x>=30){
                       throw new Exception("Число х должно быть меньше 30"); //Мы хотим, чтобы юзер ввел менее 30
                   }
                }
                catch(Exception ex){

                    System.out.println(ex.getMessage()); //Тогда выведем вот это исключение
                }
                System.out.println("Программа завершена");
            }
        }

Внимание!!! Как только происходит первая ошибка - мы получаем сообщение о ней. Вторая ошибка не
отобразится, пока не будет устранена первая.

-------------------------------------------------------------------------
/////Классы и объекты///// Пример в папке Q3ClassObjectConstructor
    Простыми словами:
        Класс: все люди.
        Объект класса: Василий Булкин

        У объекта есть две характеристики:
            Состояние - информация о Васе Булкине (Рост: 187, вес: 187, имя: Вася и т.п.)
            Поведение - Что Вася или с Васей можно сделать

        Хранится состояние в виде полей и переменных, внутри класса. Т.е. это параметры, которыми характеризуем
        всех представителей класса:
            "Рост" Васи, Пети, Димы
            "Вес" Васи, Пети, Димы
            "Имя" Васи, Пети, Димы ...

        Поведение объектов описывается МЕТОДАМИ, внутри класса.
            Например: Описали метод, который вернет все объекты, у которых вес меньше 100 кг.
                Затем, можем вызвать этот или любой другой метод, который выполнит
                операцию с объектами класса

/////Коснтрукторы/////
Это метод, для определения полей, соответствующих объектам класса.
Т.е., мы можем не описывать поля для каждого объекта, а можем обратиться к подходящему конструктору
и, просто перечислить значения полей, которые определены в конструкторе.

    Пример:
        Создадим класс с описанием полей, свойственных объекту:
            public class Person {
                String name;
                int age;
                public Person(String objName, int objAge) {
                    name = objName;
                    age = objAge;
                    }
                         }

        Создадим конструктор, который будем вызывать в main:
            public class MyConstructorForPerson{
                public personParam() {
                Person person = new Person("Вася", 12) // создание нового объекта в классе персон (имя создаваемого объекта = person)
                }
            }
-------------------------------------------------------------------------
/////Модификаторы доступа и инкапсуляция/////

Позволяют задать область видимости для членов класса.

    Модификаторы доступа:
        * public - публичный. Поля и методы видны другим классам из текущего пакета(папки) или из внешних пакетов
        * private - приватный. Доступен только кода в том же классе, в котором объявлен
        * protected - доступен в текущем классе или пакете. Так же, доступен в производных (дочерних) классах, даже
        если они в других пакетах.
        * Модификатор по умолчанию - Если модификатор отсутствует, то он = по умолчанию. Т.е., доступен и виден всем

/////Инкапсуляция/////
Применяется, когда нам необходимо ограничить изменение каких-либо переменных или методов, сделав их приватными
При этом, мы создаем геттеры и сеттеры, для предоставления доступа к ним не напрямую, а через специальные "Ручки"
При этом, сами ручки могут содерхать валидацию. Например, указать возраст можно от 0 до 100.
Сам метод, при использовании инкапсуляции, воспринимается как "Черный ящик". Наружу только "Ручки"

Геттеры ("Ручки" для получения приватных полей)
    Пример:
        public String getName(){
                return this.name;
            }
Сеттеры ("Ручки" для изменения приватных полей)
    Пример:
        public void setAge(int age){
                if(age > 0 && age < 110) // В сеттере может быть дополнительная валидация данных
                    this.age = age;
            }

-------------------------------------------------------------------------
/////Статические члены и модификатор static/////
Статичные переменные:
    Применяются не к конкретному объекту, а ко всему классу. Соответственно, ко всем объектам
        Пример: При каждом создании объекта, присваивать ему id на единицу больше предыдущего

Статические инициализаторы:
    Применяется для инициализации статической переменной при создании первого объекта
        Пример: Счетчик id должен начинаться с 1
             class Person{

                 private int id;
                 static int counter;

                 static{ //Инициализатор (Вызывается один раз)
                     counter = 105; //Стартуем счетчик со значения = 105
                     System.out.println("Static initializer");
                 }
                 Person(){ //Конструктор увеличения значения счетчика при каждом новом создании
                     id=counter++;
                     System.out.println("Constructor");
                 }
                 public void displayId(){

                     System.out.printf("Id: %d \n", id);
                 }
             }

Статичные методы:
    Применяются не к конкретному объекту, а ко всему классу. Соответственно, ко всем объектам
    В статических методах используются ТОЛЬКО статические поля/переменные
    Применяются, когда не требуется изменение состояния класса, а только параметров
        Пример:
            public class Program{

                public static void main(String[] args) {

                    System.out.println(Operation.sum(45, 23));          // 68 Результат вызова статик метода
                    System.out.println(Operation.subtract(45, 23));     // 22
                    System.out.println(Operation.multiply(4, 23));      // 92
                }
            }
            class Operation{
                static int sum(int x, int y){ //Статический метод, который принимает на вход параметры
                    return x + y;
                }
                static int subtract(int x, int y){
                    return x - y;
                }
                static int multiply(int x, int y){
                    return x * y;
                }
            }

-------------------------------------------------------------------------
/////Наследование///// Пример в пакете: Q3Legacy
Применяется для расширения функционала уже имеющихся классов.
    Например:
        1) Мы создали класс "Животные", в нем описали
        Методы:
            Животные могут "Кушать", "Спать"
        Переменные:
            У каждого животного есть кличка
        2) Мы создали класс "Собаки"
        3) Мы создали класс "Кошки"
    "Кошки" и "Собаки" - это животные. т.е., это дочерние классы от класса "Животные"
    И, следовательно, все методы, переменные, определения - всё из класса "Животные" есть и для кошек и для собак

Мы можем переопределить некоторые методы родительского класса в дочернем.
    Например:
        В классе "Собаки" определить метод, что собаки могут "Кушать", только указать, что они едят косточку
        И, при вызове в Main метода для собак и для кошек, мы получим, что кошки могут кушать, а собаки могут кушать косточку

Если необходимо из производного класса обратиться к конструктору базового класса, то применяют
ключевое слово super
    Пример:
        public class Program{

            public static void main(String[] args) {

                Person tom = new Person("Tom");
                tom.display();
                Employee sam = new Employee("Sam");
                sam.display();
            }
        }
        class Person {

            String name;
            public String getName(){ return name; }

            public Person(String name){

                this.name=name;
            }

            public void display(){

                System.out.println("Name: " + name);
            }
        }
        class Employee extends Person{
            public  Employee(String name){
                super(name);    // если базовый класс определяет конструктор
                                //  то производный класс должен его вызвать
            }
        }
Запрет наследования класса
    Если наследование класса нежелательно, то применяется ключевое слово final
        Пример:
            public final class Person {
            }

 Запрет переопределения метода:
    Пример:
          public class Person {
              //........................
              public final void display(){ // final запрещает переопределять метод в других классах
                  System.out.println("Имя: " + name);
              }
          }
-------------------------------------------------------------------------
/////Абстрактные классы/////
Отличается от обычных классов тем, что в нем нельзя создавать объекты или экземпляры.
    Пример:
        Животные - абстрактный класс
            Кошки - это животные
                Муська - конкретная кошка, которой свойственно то, что свойственно всем животным
Они предназначены предоставить базовый функционал для классов-наследников. А уже наследники-реализуют его.

    Пример:

        public abstract class Human{ //Применяется ключевое слово abstract
            private String name;
            public String getName() { return name; }
        }

Не все абстрактные методы обязательно должны быть реализованы в наследниках.

-------------------------------------------------------------------------
/////Интерфейсы/////
В отличии от наследования, интерфейсы могут применяться один во многих классах.
Интерфейс определил какой-либо функционал, а уже его потом реализуют несколько классов.
Один класс может реализовывать несколько интерфейсов.
Чтобы определить интерфейс, используется ключевое слово interface
    Пример:
        interface Printable{
            void print();
        }

Интерфейс может определять: константы и методы, которые могут иметь и не иметь реализацию.
Чтобы класс применил интерфейс, надо использовать ключевое слово implements
Если в классе применен интерфейс, то все методы интерфейса должны быть реализованы в классе.

Интерфейс нам гарантирует, что все классы, использующие интерфейс, имеют реализацию методов,
описанных в интерфейсе. Т.е., мы не забудем во вновь созданном классе что-либо реализовать

-------------------------------------------------------------------------
/////Интерфейсы в механизме обратного вызова/////
Мы создаем действие, происходящее в ответ на другое действие.
Пример:
    Включили телевизор
    Получили сообщение: "телевизор включен"
Пример работы кода в пакете Q3EventInterface

-------------------------------------------------------------------------
/////Типы коллекций. Интерфейс Collection/////
Для хранения наборов данных в Java предназначены массивы. Однако их не всегда удобно использовать,
прежде всего потому, что они имеют фиксированную длину. Эту проблему в Java решают коллекции.
Однако суть не только в гибких по размеру наборах объектов, но в и том, что классы коллекций
реализуют различные алгоритмы и структуры данных

Интерфейсы:
    * List: наследует интерфейс Collection и представляет функциональность простых списков
    * Map: предназначен для созданий структур данных в виде словаря, где каждый элемент имеет
    определенный ключ и значение.
Абстрактные классы для реализации интерфейсов:
    * AbstractList: расширяет класс AbstractCollection и применяет интерфейс List, предназначен
    для создания коллекций в виде списков
    * AbstractMap: применяет интерфейс Map, предназначен для создания наборов по типу словаря
    с объектами в виде пары "ключ-значение"
Классы коллекций:
    * ArrayList: простой список объектов
    * LinkedList: представляет связанный список
    * HashMap: структура данных в виде словаря, в котором каждый объект имеет уникальный
    ключ и некоторое значение
    * TreeMap: структура данных в виде дерева, где каждый элемент имеет уникальный ключ и
    некоторое значение

-------------------------------------------------------------------------
/////Класс ArrayList и интерфейс List///// Пример в пакете Q3ArrayListAndLinkedList
ArrayList представляет простой список, аналогичный массиву, за тем исключением,
что количество элементов в нем не фиксировано.
    ArrayList имеет следующие конструкторы:
        * ArrayList(): создает пустой список
        * ArrayList(Collection <? extends E> col): создает список, в который добавляются все элементы коллекции col.
        * ArrayList (int capacity): создает список, который имеет начальную емкость capacity

LinkedList представляет структуру данных в виде связанного списка.
Использует функционал обычного листа + очередей. т.е., есть возможность добавить элементы
в конец и начало списка

/////Класс HashMap. Интерфейс Map<K, V>/////
Представляет отображение или иначе говоря словарь,
где каждый элемент представляет пару "ключ-значение". При этом все ключи уникальные в рамках объекта Map.

Класс TreeMap. В отличие от коллекции HashMap в TreeMap все объекты автоматически сортируются
по возрастанию их ключей.



